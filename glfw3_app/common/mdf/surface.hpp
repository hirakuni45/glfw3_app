#pragma once
//=====================================================================//
/*!	@file
	@brief	サーフェース・クラス（ヘッダー）
	@author	平松邦仁 (hira@rvf-rc45.net)
*/
//=====================================================================//
#include <string>
#include <vector>
#include "utils/vtx.hpp"
#include "gl_fw/gl_info.hpp"

namespace mdf {
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
	/*!
		@brief	球を描画
		@param[in]	radius	半径
		@param[in]	lats	分割数
		@param[in]	longs	分割数
	*/
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
	void draw_sphere(float radius, int lats, int longs);

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
	/*!
		@brief	シリンダーを描画
		@param[in]	radius_org	半径（開始）
		@param[in]	radius_end	半径（終点）
		@param[in]	length		長さ
		@param[in]	lats	分割数
	*/
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
	void draw_cylinder(float radius_org, float radius_end, float length, int lats);

	
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
	/*!
		@brief	surface クラス
	*/
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
	template <typename INDEX_TYPE = uint16_t>
	struct surface {

		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
		/*!
			@brief	球を描画
			@param[in]	radius	半径
			@param[in]	lats	分割数
			@param[in]	longs	分割数
		*/
		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
		static void draw_sphere(float radius, int lats, int longs);


		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
		/*!
			@brief	頂点構造体
		*/
		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
		struct vertex {
			vtx::fpos	uv;		///< テクスチャー・コーディネート
			vtx::fvtx	n;		///< 法線
			vtx::fvtx	v;		///< 頂点			
		};


		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
		/*!
			@brief	エレメント種別
		*/
		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
		enum class element {
			TRIANGLE,	///< トライアングル
		};

		typedef uint32_t	handle;

	private:
		GLuint		vertex_id_;
		typedef std::vector<vertex>	vertexes;
		vertexes	vertexes_;

		std::vector<GLuint>	elements_;

		void destroy_vertex_();
		void destroy_element_();
	public:
		//-----------------------------------------------------------------//
		/*!
			@brief	コンストラクター
		*/
		//-----------------------------------------------------------------//
		surface() : vertex_id_(0), vertexes_(), elements_()
		{ }


		//-----------------------------------------------------------------//
		/*!
			@brief	デストラクター
		*/
		//-----------------------------------------------------------------//
		~surface() { destroy_element_(); destroy_vertex_(); }


		//-----------------------------------------------------------------//
		/*!
			@brief	頂点を開始
			@param[in]	n	数を指定する場合
			@return 成功なら「true」
		*/
		//-----------------------------------------------------------------//
		bool begin_vertex(uint32_t n = 0);


		//-----------------------------------------------------------------//
		/*!
			@brief	頂点を追加
			@param[in]	v	頂点
			@return 成功なら「true」
		*/
		//-----------------------------------------------------------------//
		bool add_vertex(const vertex& v);


		//-----------------------------------------------------------------//
		/*!
			@brief	頂点を終了
			@return 成功なら「true」
		*/
		//-----------------------------------------------------------------//
		bool end_vertex();


		//-----------------------------------------------------------------//
		/*!
			@brief	エレメントを開始
			@param[in]	t	エレメントのタイプ
			@param[in]	n	数を指定する場合
			@return 成功なら「true」
		*/
		//-----------------------------------------------------------------//
		bool begin_element(element t, uint32_t n = 0);


		//-----------------------------------------------------------------//
		/*!
			@brief	インデックスを追加
			@param[in]	idx	インデックス
			@return 成功なら「true」
		*/
		//-----------------------------------------------------------------//
		handle add_element(INDEX_TYPE idx);


		//-----------------------------------------------------------------//
		/*!
			@brief	頂点を終了
			@return 成功なら「true」
		*/
		//-----------------------------------------------------------------//
		bool end_element();


		//-----------------------------------------------------------------//
		/*!
			@brief	レンダリング
			@param[in]	h	ハンドル（０なら全てをレンダリング）
		*/
		//-----------------------------------------------------------------//
		void render(handle h);
	};
}
