#pragma once
//=====================================================================//
/*! @file
	@brief  Logic クラス @n
			※最大３２チャネルのロジックレベル操作クラス
	@author 平松邦仁 (hira@rvf-rc45.net)
*/
//=====================================================================//
#include <vector>
#include <random>

namespace tools {

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
	/*!
		@brief  ロジック・クラス
	*/
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
	class logic {

		std::vector<uint32_t>	level_;

		std::mt19937	noise_;

	public:
		//-------------------------------------------------------------//
		/*!
			@brief  コンストラクター
		*/
		//-------------------------------------------------------------//
		logic() { }


		//-------------------------------------------------------------//
		/*!
			@brief  デストラクター
		*/
		//-------------------------------------------------------------//
		~logic() { }


		//-------------------------------------------------------------//
		/*!
			@brief  波形ストレージを生成
			@param[in]	length	長さ
		*/
		//-------------------------------------------------------------//
		void create(uint32_t length)
		{
			level_.resize(length);
		}


		//-------------------------------------------------------------//
		/*!
			@brief  ストレージをクリア
		*/
		//-------------------------------------------------------------//
		void clear() { level_.clear(); }


		//-------------------------------------------------------------//
		/*!
			@brief  サイズの取得
			@return サイズ
		*/
		//-------------------------------------------------------------//
		uint32_t size() const { return level_.size(); }


		//-------------------------------------------------------------//
		/*!
			@brief  ロジック・レベルの取得
			@param[in]	wpos	波形位置
			@param[in]	ch		チャネル（０～３１）
			@return レベル
		*/
		//-------------------------------------------------------------//
		bool get_logic(uint32_t wpos, uint32_t ch) const
		{
			if(wpos >= level_.size()) return 0;  // 範囲外は「０」

			return level_[wpos] & (1 << ch);
		}


		//-------------------------------------------------------------//
		/*!
			@brief  ロジック・レベル設定
			@param[in]	wpos	波形位置
			@param[in]	ch	チャネル（０～３１）
			@param[in]	value	値
		*/
		//-------------------------------------------------------------//
		void set_logic(uint32_t wpos, uint32_t ch, bool value = true)
		{
			if(wpos >= level_.size()) return;

			if(value) level_[wpos] |= (1 << ch);
			else level_[wpos] &= ~(1 << ch);
		}


		//-------------------------------------------------------------//
		/*!
			@brief  ロジック・レベルの反転
			@param[in]	wpos	波形位置
			@param[in]	ch		チャネル（０～３１）
			@return 反転後のレベル
		*/
		//-------------------------------------------------------------//
		bool flip_logic(uint32_t wpos, uint32_t ch)
		{
			if(wpos >= level_.size()) return 0;  // 範囲外は「０」

			level_[wpos] ^= (1 << ch);
			return level_[wpos] & (1 << ch);
		}


		//-------------------------------------------------------------//
		/*!
			@brief  クロック信号の生成
			@param[in]	ch	チャネル（０～３１）
			@param[in]	udu	デューティー分子（１）
			@param[in]	ddu	デューティー分母（２）
			@param[in]	ph	フェーズ（分子初期値）
		*/
		//-------------------------------------------------------------//
		void build_clock(uint32_t ch, uint32_t udu = 1, uint32_t ddu = 2, uint32_t ph = 0)
		{
			uint32_t sum = ph;
			uint8_t v = 0;
			for(uint32_t i = 0; i < level_.size(); ++i) {
				sum += udu;
				v = sum <= udu ? 0 : 1;
				set_logic(i, ch, (v & 1));
				if(sum >= ddu) {
					sum -= ddu;
				}
			}
		}


		//-------------------------------------------------------------//
		/*!
			@brief  ノイズ生成シード設定
			@param[in]	seed	シード
		*/
		//-------------------------------------------------------------//
		void set_noise_seed(uint32_t seed)
		{
			noise_.seed(seed);
		}


		//-------------------------------------------------------------//
		/*!
			@brief  ノイズの生成
			@param[in]	ch	チャネル（０～３１）
			@param[in]	org	開始位置
			@param[in]	len	長さ（０の場合、最大サイズ）
		*/
		//-------------------------------------------------------------//
		void build_noise(uint32_t ch, uint32_t org = 0, uint32_t len = 0)
		{
			if(len == 0) len = size() - org;
			for(uint32_t i = org; i < (org + len); ++i) {
				set_logic(i, ch, noise_() & 1);
			}
		}


		//-------------------------------------------------------------//
		/*!
			@brief  埋める
			@param[in]	ch	チャネル（０～３１）
			@param[in]	lvl	値
			@param[in]	org	開始位置
			@param[in]	len	長さ（０の場合、最大サイズ）
		*/
		//-------------------------------------------------------------//
		void fill(uint32_t ch, bool lvl, uint32_t org, uint32_t len = 0)
		{
			if(len == 0) len = size() - org;
			for(uint32_t i = org; i < (org + len); ++i) {
				set_logic(i, ch, lvl);
			}
		}


		//-------------------------------------------------------------//
		/*!
			@brief  反転
			@param[in]	ch	チャネル（０～３１）
			@param[in]	lvl	値
			@param[in]	org	開始位置
			@param[in]	len	長さ（０の場合、最大サイズ）
		*/
		//-------------------------------------------------------------//
		void flip(uint32_t ch, bool lvl, uint32_t org, uint32_t len = 1)
		{
			if(len == 0) len = size() - org;

			for(uint32_t i = org; i < (org + len); ++i) {
				flip_logic(i, ch);
			}
		}


		//-------------------------------------------------------------//
		/*!
			@brief  波形の取得
			@param[in]	wpos	波形位置
			@return 波形
		*/
		//-------------------------------------------------------------//
		uint32_t get(uint32_t wpos) const {
			if(wpos >= level_.size()) return 0;
			return level_[wpos];
		}


		//-------------------------------------------------------------//
		/*!
			@brief  参照
			@param[in]	pos	参照位置
			@return 現物
		*/
		//-------------------------------------------------------------//
		uint32_t& at(uint32_t pos) { return level_[pos]; }
	};
}
